/**
\page pyJac_ex Use with pyJac

Compared to implementation of the \ref vdp van der Pol problem, use of `accelerInt` with @pyJac is quite simple.

\section gen File Geneneration

After installing pyJac (via [github](https://github.com/SLACKHA/pyJac) or [pypi](https://pypi.python.org/pypi/pyJac)), the required
C/CUDA implementation files can be generated e.g. for the included [\f$\ce{H2}\slash\ce{CO}\f$ model](http://onlinelibrary.wiley.com/doi/10.1002/kin.20603/abstract) via:

      python -m pyjac -i examples/pyJac/h2.cti -l c -b examples/pyJac/out/ -ic 1000,1,H2=1,O2=0.5,N2=1.76
      python -m pyjac -i examples/pyJac/h2.cti -l cuda -b examples/pyJac/out/ -ic 1000,1,H2=1,O2=0.5,N2=1.76

- Note: the `-ic` parameter sets the initial conditions, similar to set_same_initial_conditions() in the \ref "vdp van der Pol" example.

\section build Building Solvers

Next the solvers can be built via:

      scons SAME_IC=True LOG_OUTPUT=True LOG_END_ONLY=False t_end=1e-3 t_step=1e-6 mechanism_dir=examples/pyJac/out/ -j 2

- The `j` parameter allows scons to use 2 threads during compilation (vary as necessary)
- The `mechanism_dir` option tells scons to look in the `pyJac\out` example directory for the required dydt() and eval_jacob() functions.
- We log the output to a file (generated by default in `accelerInt-root/log/solvername.bin`), for plotting.\n
- The time step #t_step is set to \f$\num{1e-6}\f$ second, while the end time #end_time is set to \f$\num{1e-4}\f$ seconds.
- The default error tolerances #ATOL/#RTOL = \f$\num{e-10}\text{ and }\num{e-6}\f$ respectively are used.
- Additionaly the #PRINT=True option tuns on logging to the screen (if so desired)
- Alternatively, randomized initial conditions generated by generate_ics.py may be used by copying the resulting `ign_data.bin` file to the root `accelerInt` folder, and compiling without the #SAME_IC option.

\section results Running the Solvers and Plotting Results

The CPU solvers can be called using:

        ./solver_name [num_threads] [num_odes]

While the GPU solvers are called via:

        ./solver_name [num_odes]

For example, we call:

        ./exprb43-int 1 1
        ./cvodes-int 1 1
        ./radau2a-int-gpu 1

Next, we load the data and plot (plotter.py), resulting in:

\image html ./h2ign.png "Solver output for Constant Pressure H2 Ignition at 1000 K, 1 atm, phi = 1" width=10cm

*/